# -*- coding: utf-8 -*-
"""Essentials to Data Science

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19_Y_cWYMUXWlR6wbJDl8cI-xiYU10C4a

# Essential Tools Workshop: pandas, NumPy, matplotlib  
**Goal:** Load some data, make a scatter plot, and draw a simple line of best fit.  
_Side quest:_ learn just enough pandas/NumPy/matplotlib to be dangerous (and charming).

## Setup
We'll import the three musketeers of Python data work:
- **pandas** for tables,
- **NumPy** for numbers,
- **matplotlib** for plots.
"""

# Commented out IPython magic to ensure Python compatibility.

# If you're running locally and need to install:
# !pip install pandas numpy matplotlib

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Jupyter nicety so plots show up below each cell
# %matplotlib inline

"""
## Step 1. Get some data (two options)
We'll create a small CSV (so nobody has to download anything) **and** show how to read it.

**Columns:**
- `hours_studied` (x)
- `exam_score` (y)
"""

import os

# Create a tiny dataset (a little noise keeps it real)
rng = np.random.default_rng(7)
hours = np.linspace(0, 10, 30)
scores = 50 + 5*hours + rng.normal(0, 5, size=hours.size)

demo = pd.DataFrame({
    "hours_studied": hours.round(2),
    "exam_score": scores.round(2)
})

print("Wrote data/study_scores.csv with", len(demo), "rows")
demo.head()

"""
## Step 2. pandas 101 (reading, peeking, selecting)
pandas turns your CSV into a **DataFrame** (a table with superpowers).
"""

# Read the CSV
df = demo  # replace with pd.read_csv("data/study_scores.csv") if needed

# Quick peeks
display(df.head())          # first five rows
display(df.tail(3))         # last three rows
display(df.sample(5))       # a random sample

# Structure & summary
display(df.info())          # column names + types + missing values
display(df.describe())      # basic stats (mean, std, min, max, quartiles)

"""
### Selecting columns & rows
- Column(s): `df["col"]` or `df[["col1","col2"]]`  
- Row filter: boolean masks like `df[df["hours_studied"] > 5]`
"""

x = df["hours_studied"]            # a pandas Series
y = df["exam_score"]               # another Series

over_5 = df[df["hours_studied"] > 5]
display(over_5.head())

"""
# Step 3. Cleaning basics (a tiny taste)
Real data is messy. A few handy moves:
- `dropna()` to remove missing values
- `fillna(value)` to fill them
- `rename(columns={...})` to tidy names
- type conversions: `df["col"].astype(float)`
"""

# (Our toy data is already clean, but here's the pattern.)
df_clean = (
    df
    .dropna()
    .rename(columns={"hours_studied": "hours", "exam_score": "score"})
)
display(df_clean.head())

"""
## Step 4. NumPy 101 (arrays, simple math)
NumPy is great for **numeric operations** and quick math on arrays.
"""

hours_np = df_clean["hours"].to_numpy()
score_np = df_clean["score"].to_numpy()

print("hours type:", type(hours_np), "shape:", hours_np.shape)
print("score  mean:", np.mean(score_np).round(2), "| std:", np.std(score_np).round(2))

# A quick transform example (no need to use it later—just demoing)
scaled_hours = (hours_np - hours_np.mean()) / hours_np.std()
scaled_hours[:5]

"""
## Step 5. matplotlib 101 (scatter plots)
Minimal recipe for a scatter plot:
1. `plt.figure()` to start a new figure
2. `plt.scatter(x, y)` to plot dots
3. Labels + title so Future You knows what's going on
4. `plt.show()` (shown automatically in notebooks)
"""

plt.figure()
plt.scatter(df_clean["hours"], df_clean["score"])
plt.xlabel("Hours studied")
plt.ylabel("Exam score")
plt.title("Hours vs. Score (scatter)")
plt.grid(True, alpha=0.3)
plt.show()

"""
## Step 6. A simple line of best fit (with NumPy)
We can fit a straight line \( y = m x + b \) using `np.polyfit(x, y, 1)`.

- `m` = slope (how much the score changes per extra hour)
- `b` = intercept (score when hours = 0)

We'll plot the line **on top** of the scatter plot.
"""

# Fit a first-degree polynomial (a line): y ≈ m*x + b
m, b = np.polyfit(df_clean["hours"], df_clean["score"], 1)

# Create x-values across the range to draw the line
x_line = np.linspace(df_clean["hours"].min(), df_clean["hours"].max(), 100)
y_line = m * x_line + b

print(f"slope (m) = {m:.3f}, intercept (b) = {b:.3f}")

plt.figure()
plt.scatter(df_clean["hours"], df_clean["score"], label="data")
plt.plot(x_line, y_line, label="best-fit line", color="red")
plt.xlabel("Hours studied")
plt.ylabel("Exam score")
plt.title("Hours vs. Score with Line of Best Fit")
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

"""
## Step 7. Save your work
Always nice to keep artifacts:
- a cleaned CSV
- a plot image
"""

import os
os.makedirs("./outputs/figures", exist_ok=True)
os.makedirs("./data/processed", exist_ok=True)

# Save a clean CSV
df_clean.to_csv("data/processed/study_scores_clean.csv", index=False)

# Recreate & save the plot
plt.figure()
plt.scatter(df_clean["hours"], df_clean["score"])
plt.plot(x_line, y_line)
plt.xlabel("Hours studied")
plt.ylabel("Exam score")
plt.title("Hours vs. Score with Line of Best Fit")
plt.grid(True, alpha=0.3)
plt.savefig("outputs/figures/hours_vs_score.png", bbox_inches="tight")
"Saved: outputs/figures/hours_vs_score.png"

"""## Step 8. Wrap-up
You just:
- loaded a CSV with **pandas**,
- wrangled a few basics,
- did simple math with **NumPy**,
- made a scatter plot and best-fit line with **matplotlib** + **NumPy**.

Next step in the series: bring data from a **database (SQL)** instead of a single CSV.

# Main.Py

main.py is the script version of our notebook — it loads a CSV with pandas, cleans missing data, and uses NumPy to fit a simple linear regression between two columns. It then calls visualize.py to plot a scatter chart with the best-fit line. In short, it turns the notebook’s step-by-step demo into a real, runnable Python program.
"""

import numpy as np
import matplotlib.pyplot as plt

def show_fit(x, y, m, b, title="Linear Fit", xlabel="x", ylabel="y"):
    plt.figure()
    plt.scatter(x, y, label="data")
    # Draw a smooth line across the x-range
    x_line = np.linspace(np.min(x), np.max(x), 200)
    plt.plot(x_line, m * x_line + b, label="best-fit line", color="red")
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.show()

import sys
  import pandas as pd
  import numpy as np

  #-------- Setup --------
  # python -m venv .venv
  # source .venv/bin/activate  # MacOS/Linux
  # .\.venv\Scripts\activate   # Windows
  # pip install -r requirements.txt

  #-------- CSVS --------
  # Example CSVs:
  # - salaries.csv (Hard)
  # - housing.csv (Medium)
  # - studying.csv (Easy)

  #-------- Usage --------
  # python main.py [csv_name] [COL_X] [COL_Y]

  #-------- What you need to fix --------
  # Fill in the blanks (____) and remove comments (--- IGNORE ---)
  # Fill in the blanks at lines 33, 60, 73.

  # -------- CLI / Defaults --------
  CSV_PATH = "sample_data/housing.csv"
  COL_X = "square_feet"
  COL_Y = "price_usd"
  # -------- Load & peek --------
  # Create the dataframe by loading the CSV (what function can you use)
  df = pd.read_csv(CSV_PATH)


  print("\n=== HEAD ===")
  print(df.head().to_string(index=False))

  print("\n=== INFO ===")
  df.info()

  print("\n=== DESCRIBE ===")
  print(df.describe(include="all").transpose().to_string())

  # -------- Pick two columns --------
  if COL_X not in df.columns or COL_Y not in df.columns:
      print(f"\nSet valid columns. Available: {list(df.columns)}")
      sys.exit(1)

  data = df[[COL_X, COL_Y]].copy()

  # -------- Clean & drop NAs --------
  for col in [COL_X, COL_Y]:
      data[col] = pd.to_numeric(
          data[col].astype(str).str.replace(",", "").str.replace("$", "").str.replace("%", ""),
          errors="coerce"
      )

  before = len(data)

  # ~~~~~~~~~ drop rows in data with NAs (what function can you use) ~~~~~~~~~
  data=data.dropna()

  print(f"\nDropped {before - len(data)} rows after cleaning & removing NAs.")

  # -------- Regression --------
  x = data[COL_X].to_numpy()
  y = data[COL_Y].to_numpy()

  if len(x) < 2:
      raise ValueError("Not enough data points to fit a line.")

  # ~~~~~~~~~ fit a line to x, y (what function can you use) ~~~~~~~~~
  # ~~~~~~~~~ store slope in m and intercept in b ~~~~~~~~~
  m, b = np.polyfit(x,y, 1)

  print(f"\nRegression: {COL_Y} ≈ {m:.4f} * {COL_X} + {b:.4f}")

  # -------- Plot --------
  show_fit(
      x=x,
      y=y,
      m=m,
      b=b,
      title=f"{COL_X} vs {COL_Y} (Linear Fit)",
      xlabel=COL_X,
      ylabel=COL_Y,
  )